module LanguageFortranTools where

import Data.Generics (Data, Typeable, mkQ, mkT, gmapQ, gmapT, everything, everywhere)
import Data.Typeable
import Language.Fortran.Parser
import Language.Fortran
import Data.Char
import Data.List
import System.Process
import System.Directory
import qualified Data.Map as DMap

import PreProcessor

type Anno = DMap.Map (String) [String]

nullAnno :: Anno
nullAnno = DMap.empty

--	Taken from language-fortran example. Runs preprocessor on target source and then parses the result, returning an AST.
parseFile s = do inp <- readProcess "cpp" [s, "-D", "NO_IO", "-P"] "" 
                 return $ parse $ preProcess inp

cpp s = do 	inp <- readProcess "cpp" [s, "-D", "NO_IO", "-P"] "" 
        	return inp

--	Used by analyseLoop_map to format the information on the position of a particular piece of code that is used as the information
--	output to the user
errorLocationFormatting :: SrcSpan -> String
errorLocationFormatting ((SrcLoc filename line column), srcEnd) = show line ++ ":" ++ show column --"line " ++ show line ++ ", column " ++ show column

errorLocationRangeFormatting :: SrcSpan -> String
errorLocationRangeFormatting ((SrcLoc _ line_start _), (SrcLoc _ line_end _)) = "line " ++ show line_start ++ " and line " ++ show line_end -- ++ ", column " ++ show column

outputExprFormatting :: Expr Anno -> String
outputExprFormatting (Var _ _ list) = foldl (++) "" (map (\(varname, exprList) -> ((\(VarName _ str) -> str) varname) ++ 
															(if exprList /= [] then "(" ++ (foldl (\accum item -> (if accum /= "" then accum ++ "," else "") 
																++ item) "" (map (outputExprFormatting) exprList)) ++ ")" else "")) list)
outputExprFormatting (Con _ _ str) = str
outputExprFormatting (Bin _ _ op expr1 expr2) = "(" ++ outputExprFormatting expr1 ++ " " ++ op_str ++ " " ++ outputExprFormatting expr2 ++ ")"
							where
								op_str = case op of
									Plus p -> "+"
									Minus p -> "-"
									Mul p -> "*"
									Div p -> "/"
									Or p -> ".OR."
									And p -> ".AND."
									Concat p -> "//"
									Power p -> "**"
									RelEQ p -> "=="
									RelNE p -> "/="
									RelLT p -> "<"
									RelLE p -> "<="
									RelGT p -> ">"
									RelGE p -> ">="
outputExprFormatting (NullExpr _ _) = ""
outputExprFormatting (Null _ _) = "null"
outputExprFormatting (Unary _ _ unOp expr) = "(" ++ op_str ++ outputExprFormatting expr ++ ")"
							where 
								op_str = case unOp of
									UMinus p -> "-"
									Not p -> ".NOT."

outputExprFormatting codeSeg = show codeSeg

--	Generic function that removes all duplicate elements from a list.
listRemoveDuplications :: Eq a => [a] -> [a]
listRemoveDuplications a = foldl (\accum item -> if notElem item accum then accum ++ [item] else accum) [] a

--	Used by SYB query to extract expressions
extractExpr :: Expr Anno -> Expr Anno 
extractExpr expr = expr

extractExpr_list :: Expr Anno -> [Expr Anno] 
extractExpr_list expr = [expr]

--	Used to break down a tree of expressions that might form a calculation into a list of expressions for analysis.
extractOperands :: (Typeable p, Data p) => Expr p -> [Expr p]
extractOperands (Bin _ _ _ expr1 expr2) = extractOperands expr1 ++ extractOperands expr2
extractOperands expr 					= [expr]

--	Used to extract the name of a Var in a particular expression
extractVarNames :: (Typeable p, Data p) => Expr p -> [VarName p]
extractVarNames (Var _ _ lst) = map (\(x, _) -> x) lst
extractVarNames _ = []

--	Used to extract array index expressions and function call arguments.
extractContainedVars :: (Typeable p, Data p) => Expr p -> [Expr p]
extractContainedVars (Var _ _ lst) = foldl (\accumExprs (itemVar, itemExprs) -> accumExprs ++ itemExprs) [] lst
extractContainedVars _ = []

extractFortran :: Fortran Anno -> [Fortran Anno]
extractFortran fort = [fort]

extractBlock :: Block Anno -> [Block Anno]
extractBlock block = [block]

--	Generates a SrcSpan that is attached to nodes that have been generated by this program
nullSrcSpan :: SrcSpan
nullSrcSpan = (SrcLoc {srcFilename = "generated", srcLine = -1, srcColumn = -1}, SrcLoc {srcFilename = "generated", srcLine = -1, srcColumn = -1})

generateSrcSpan :: SrcSpan -> SrcSpan
generateSrcSpan ((SrcLoc sFile sLine sCol), (SrcLoc eFile eLine eCol)) = (SrcLoc {srcFilename = "generated", srcLine = sLine, srcColumn = sCol}, SrcLoc {srcFilename = "generated", srcLine = eLine, srcColumn = eCol})

generateAssgCode :: Expr Anno -> Expr Anno -> Fortran Anno
generateAssgCode expr1 expr2 = Assg nullAnno nullSrcSpan expr1 expr2 

generateLTExpr :: Expr Anno -> Expr Anno -> Expr Anno
generateLTExpr expr1 expr2 = Bin nullAnno nullSrcSpan (RelLT nullAnno) expr1 expr2

generateAndExpr :: Expr Anno -> Expr Anno -> Expr Anno
generateAndExpr expr1 expr2 = Bin nullAnno nullSrcSpan (And nullAnno) expr1 expr2

generateAndExprFromList :: [Expr Anno] -> Expr Anno
generateAndExprFromList list = foldl1 (generateAndExpr) list

generateVar :: VarName Anno -> Expr Anno
generateVar varname = Var nullAnno nullSrcSpan [(varname, [])]

generateConstant :: Int -> Expr Anno
generateConstant value = Con nullAnno nullSrcSpan (show value)

generateArrayVar :: VarName Anno -> Expr Anno -> Expr Anno
generateArrayVar varname access = Var nullAnno nullSrcSpan [(varname, [access])]

generateIf :: Expr Anno -> Fortran Anno -> Fortran Anno
generateIf expr fortran = If nullAnno nullSrcSpan expr fortran [] Nothing

generateAdditionExpr :: Expr Anno -> Expr Anno -> Expr Anno
generateAdditionExpr expr1 expr2 = Bin nullAnno nullSrcSpan (Plus nullAnno) expr1 expr2

generateProductExpr :: Expr Anno -> Expr Anno -> Expr Anno
generateProductExpr expr1 expr2 = Bin nullAnno nullSrcSpan (Mul nullAnno) expr1 expr2

generateSubtractionExpr :: Expr Anno -> Expr Anno -> Expr Anno
generateSubtractionExpr expr1 expr2 = Bin nullAnno nullSrcSpan (Minus nullAnno) expr1 expr2

generateDivisionExpr :: Expr Anno -> Expr Anno -> Expr Anno
generateDivisionExpr expr1 expr2 = Bin nullAnno nullSrcSpan (Div nullAnno) expr1 expr2

--	Used to standardise SrcSpans so that nodes of an AST may be matched up even if they appear in completely different
--	parts of a program. Also used to signify that a node has been changed and cannot be copied from the orignal source during code
--	generation
applyGeneratedSrcSpans :: (Data (a Anno)) => a Anno -> a Anno
applyGeneratedSrcSpans = everywhere (mkT (standardiseSrcSpan))

standardiseSrcSpan :: SrcSpan -> SrcSpan
standardiseSrcSpan src = nullSrcSpan

hasOperand :: Expr Anno -> Expr Anno -> Bool
hasOperand container contains = all (== True) $ map (\x -> elem x (extractOperands $ applyGeneratedSrcSpans container)) (extractOperands $ applyGeneratedSrcSpans contains)

--	Appends a new item to the list of annotations already associated to a particular node
appendAnnotation :: Fortran Anno -> String -> String -> Fortran Anno
appendAnnotation original key appendage = case original of
		For anno f2 f3 f4 f5 f6 f7 -> For (appendToMap key appendage anno) f2 f3 f4 f5 f6 f7
		OpenCLMap anno f2 f3 f4 f5 f6 -> OpenCLMap (appendToMap key appendage anno) f2 f3 f4 f5 f6
		OpenCLReduce anno f2 f3 f4 f5 f6 f7 -> OpenCLReduce (appendToMap key appendage anno) f2 f3 f4 f5 f6 f7
		--For anno f2 f3 f4 f5 f6 f7 -> For (anno ++ [appendage]) f2 f3 f4 f5 f6 f7
		--OpenCLMap anno f2 f3 f4 f5 f6 -> OpenCLMap (anno ++ [appendage]) f2 f3 f4 f5 f6
		--OpenCLReduce anno f2 f3 f4 f5 f6 f7 -> OpenCLReduce (anno ++ [appendage]) f2 f3 f4 f5 f6 f7
		_ -> original

		-- appendToMap

appendAnnotationMap :: Fortran Anno -> Anno -> Fortran Anno
appendAnnotationMap codeSeg newMap = case codeSeg of
		For anno f2 f3 f4 f5 f6 f7 -> For (combineAnnotations newMap anno) f2 f3 f4 f5 f6 f7
		OpenCLMap anno f2 f3 f4 f5 f6 -> OpenCLMap (combineAnnotations newMap anno) f2 f3 f4 f5 f6
		OpenCLReduce anno f2 f3 f4 f5 f6 f7 -> OpenCLReduce (combineAnnotations newMap anno) f2 f3 f4 f5 f6 f7

-- appendAnnotation original appendage = original

--	Prepends a new item to the list of annotations already associated to a particular node
prependAnnotation :: Fortran Anno -> String -> Fortran Anno
prependAnnotation original appendage = case original of
		--For anno f2 f3 f4 f5 f6 f7 -> For ([appendage] ++ anno) f2 f3 f4 f5 f6 f7
		--OpenCLMap anno f2 f3 f4 f5 f6 -> OpenCLMap ([appendage] ++ anno) f2 f3 f4 f5 f6
		--OpenCLReduce anno f2 f3 f4 f5 f6 f7 -> OpenCLReduce ([appendage] ++ anno) f2 f3 f4 f5 f6 f7
		_ -> original

--removeAllAnnotations :: Fortran Anno -> Fortran Anno
removeAllAnnotations original = everywhere (mkT removeAnnotations) original

removeAnnotations :: Fortran Anno -> Fortran Anno
removeAnnotations original = case original of
		For anno f2 f3 f4 f5 f6 f7 -> For nullAnno f2 f3 f4 f5 f6 f7
		OpenCLMap anno f2 f3 f4 f5 f6 -> OpenCLMap nullAnno f2 f3 f4 f5 f6
		OpenCLReduce anno f2 f3 f4 f5 f6 f7 -> OpenCLReduce nullAnno f2 f3 f4 f5 f6 f7
		_ -> original

combineAnnotations :: Anno -> Anno -> Anno
combineAnnotations a b = combineMaps a b


usesVarName_list :: [VarName Anno] -> Expr Anno -> Bool
usesVarName_list loopWrites (Var _ _ list) = foldl (||) False $ map (\(varname, exprs) -> elem varname loopWrites) list
usesVarName_list loopWrites _ = False

usesVarName :: VarName Anno -> Expr Anno -> Bool
usesVarName varnameInp (Var _ _ list) = foldl (||) False $ map (\(varname, exprs) -> varname == varnameInp) list
--usesVarName varnameInp _ = False

isVar :: Expr Anno -> Bool
isVar (Var _ _ _) = True
isVar _ = False

extractUsedVarName :: Expr Anno -> [VarName Anno]
extractUsedVarName (Var _ _ list) = map (\(varname, exprs) -> varname) list
extractUsedVarName _ = []

replaceAllOccurences_varnamePairs :: Fortran Anno -> [VarName Anno] -> [VarName Anno] -> Fortran Anno
replaceAllOccurences_varnamePairs codeSeg originals replacements = foldl (\accum (v1, v2) -> replaceAllOccurences_varname accum v1 v2) codeSeg pairs
					where
						pairs = zip originals replacements

-- replaceAllOccurences_varname :: Fortran Anno -> VarName Anno -> VarName Anno -> Fortran Anno
replaceAllOccurences_varname :: (Data (a Anno)) => a Anno -> VarName Anno -> VarName Anno -> a Anno
replaceAllOccurences_varname codeSeg original replacement = everywhere (mkT (replaceVarname original replacement)) codeSeg

replaceVarname :: VarName Anno -> VarName Anno -> VarName Anno -> VarName Anno
replaceVarname original replacement inp 	| 	original == inp = replacement
											|	otherwise = inp


varnameStr :: VarName Anno -> String
varnameStr (VarName _ str) = str

--	Takes two ASTs and appends on onto the other so that the resulting AST is in the correct format
appendFortran_recursive :: Fortran Anno -> Fortran Anno -> Fortran Anno
--appendFortran_recursive newFortran (FSeq _ _ _ (FSeq _ _ _ fortran1)) = appendFortran_recursive newFortran fortran1 
--appendFortran_recursive newFortran (FSeq anno1 src1 fortran1 (FSeq anno2 src2 fortran2 fortran3)) = FSeq anno1 src1 fortran1 (FSeq anno2 src2 fortran2 (appendFortran_recursive newFortran fortran3)) 
appendFortran_recursive newFortran (FSeq anno1 src1 fortran1 (NullStmt anno2 src2)) = FSeq anno1 src1 fortran1 newFortran
appendFortran_recursive newFortran (FSeq anno1 src1 fortran1 fortran2) = FSeq anno1 src1 fortran1 (appendFortran_recursive newFortran fortran2)
appendFortran_recursive newFortran codeSeg = FSeq nullAnno nullSrcSpan codeSeg newFortran

--	Takes an AST and removes the loop statements from the node and joins up the rest of the code so that is it represented in the
--	format that language-fortran uses.
removeLoopConstructs_recursive :: Fortran Anno -> Fortran Anno
removeLoopConstructs_recursive (FSeq anno _ (For _ _ _ _ _ _ fortran1) fortran2) = removeLoopConstructs_recursive $ appendFortran_recursive fortran2 fortran1
removeLoopConstructs_recursive (For _ _ _ _ _ _ fortran) = removeLoopConstructs_recursive fortran
--removeLoopConstructs_recursive (OpenCLMap _ _ _ _ _ fortran1) = removeLoopConstructs_recursive fortran1
--removeLoopConstructs_recursive (OpenCLReduce _ _ _ _ _ _ fortran1) = removeLoopConstructs_recursive fortran1
removeLoopConstructs_recursive (FSeq _ _ fortran (NullStmt _ _)) = removeLoopConstructs_recursive fortran
removeLoopConstructs_recursive codeSeg = codeSeg

extractLineNumber :: SrcSpan -> Int
extractLineNumber ((SrcLoc _ line _), _) = line

getEarliestSrcSpan :: [SrcSpan] -> Maybe(SrcSpan)
getEarliestSrcSpan [] = Nothing
getEarliestSrcSpan spans = Just (foldl (\accum item -> if checkSrcSpanBefore item accum then item else accum) (spans!!0) spans)

checkSrcSpanBefore :: SrcSpan -> SrcSpan -> Bool
checkSrcSpanBefore ((SrcLoc file_before line_before column_before), beforeEnd) ((SrcLoc file_after line_after column_after), afterEnd) = (line_before < line_after) || ((line_before == line_after) && (column_before < column_after))

checkSrcSpanBefore_line :: SrcSpan -> SrcSpan -> Bool
checkSrcSpanBefore_line ((SrcLoc file_before line_before column_before), beforeEnd) ((SrcLoc file_after line_after column_after), afterEnd) = (line_before < line_after)

generateSrcSpanMerge :: SrcSpan -> SrcSpan -> SrcSpan
generateSrcSpanMerge src1 src2 = (src1_s, src2_e)
					where
						(src1_s, src1_e) = src1
						(src2_s, src2_e) = src2

getSrcSpanNonIntersection :: SrcSpan -> SrcSpan -> (SrcSpan, SrcSpan)
getSrcSpanNonIntersection src1 src2 = (firstSrc, secondSrc)
					where
						(src1_s, src1_e) = src1
						(src2_s, src2_e) = src2

						firstSrc = (src1_s, src2_s)
						secondSrc = (src2_e, src1_e)

--	Generic function that takes two lists a and b and returns a +list c that is all of the elements of a that do not appear in b.
listSubtract :: Eq a => [a] -> [a] -> [a]
listSubtract a b = filter (\x -> notElem x b) a

listIntersection :: Eq a => [a] -> [a] -> [a]
listIntersection a b = filter (\x -> elem x b) a

combineMaps :: Ord k => DMap.Map k [a] -> DMap.Map k [a] -> DMap.Map k [a]
combineMaps map1 map2 = resultantAnalysis
						where
							map2List = DMap.toList map2
							resultantAnalysis = foldl (\accum (key, value) -> DMap.insert key ((DMap.findWithDefault [] key accum) ++ value) accum) map1 map2List

appendToMap :: Ord k => k -> a -> DMap.Map k [a] -> DMap.Map k [a]
appendToMap key item map = DMap.insert key ((DMap.findWithDefault [] key map) ++ [item]) map

extractPrimaryReductionOp :: Expr Anno -> Expr Anno -> Maybe(BinOp Anno)
extractPrimaryReductionOp assignee (Bin _ _ op expr1 expr2) = case assigneePresent of
										True -> Just op
										False -> childOp
						where
							primaryOp1 = extractPrimaryReductionOp assignee expr1
							primaryOp2 = extractPrimaryReductionOp assignee expr2 
							childOp = case primaryOp1 of
										Just a -> primaryOp1
										Nothing ->  primaryOp2
							assigneePresent = applyGeneratedSrcSpans expr1 == applyGeneratedSrcSpans assignee ||
												applyGeneratedSrcSpans expr2 == applyGeneratedSrcSpans assignee
extractPrimaryReductionOp assignee assignment = Nothing

extractPrimaryReductionFunction ::  Expr Anno -> Expr Anno -> String
extractPrimaryReductionFunction assignee (Var _ _ list) = foldl assigneePresent "" list
						where
							assigneePresent = (\accum (var, exprList) -> if elem (applyGeneratedSrcSpans assignee) exprList then varnameStr var else accum)
							standardisedList = map (\(var, exprList) -> (var, map (applyGeneratedSrcSpans) exprList)) list
extractPrimaryReductionFunction assignee expr = "" -- error ("Error: extractPrimaryReductionFunction\nType: " ++ (show $ typeOf expr) ++ "\nShow: " ++ (show expr))

trimFront :: String -> String
trimFront inp = filter (\x -> x /= ' ' && x /= '\t') inp

--	Value used as a global spacing measure. Used for output formatting.
outputTab :: String
outputTab = "  "

compilerName :: String
compilerName = "ParallelFortran"