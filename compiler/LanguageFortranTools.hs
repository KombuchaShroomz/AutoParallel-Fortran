module LanguageFortranTools where

import Data.Generics (Data, Typeable, mkQ, mkT, gmapQ, gmapT, everything, everywhere)
import Language.Fortran.Parser
import Language.Fortran
import Data.Char
import Data.List

--	Used by analyseLoop_map to format the information on the position of a particular piece of code that is used as the information
--	output to the user
errorLocationFormatting :: SrcSpan -> String
errorLocationFormatting ((SrcLoc filename line column), srcEnd) = show line ++ ":" ++ show column --"line " ++ show line ++ ", column " ++ show column

errorLocationRangeFormatting :: SrcSpan -> String
errorLocationRangeFormatting ((SrcLoc _ line_start _), (SrcLoc _ line_end _)) = "line " ++ show line_start ++ " and line " ++ show line_end -- ++ ", column " ++ show column

errorExprFormatting :: Expr [String] -> String
errorExprFormatting (Var _ _ list) = foldl (++) "" (map (\(varname, exprList) -> ((\(VarName _ str) -> str) varname) ++ 
															(if exprList /= [] then "(" ++ (foldl (\accum item -> (if accum /= "" then accum ++ "," else "") 
																++ item) "" (map (errorExprFormatting) exprList)) ++ ")" else "")) list)
errorExprFormatting (Con _ _ str) = str
errorExprFormatting (Bin _ _ op expr1 expr2) = errorExprFormatting expr1 ++ " " ++ op_str ++ " " ++ errorExprFormatting expr2
							where
								op_str = case op of
									Plus p -> "+"
									Minus p -> "-"
									Mul p -> "*"
									Div p -> "/"
									Or p -> " or "
									And p -> " and "
									_ -> "binOp"
errorExprFormatting codeSeg = show codeSeg

--	Generic function that removes all duplicate elements from a list.
listRemoveDuplications :: Eq a => [a] -> [a]
listRemoveDuplications a = foldl (\accum item -> if notElem item accum then accum ++ [item] else accum) [] a

--	Used by SYB query to extract expressions
extractExprs :: Expr [String] -> Expr [String] 
extractExprs expr = expr

--	Used to break down a tree of expressions that might form a calculation into a list of expressions for analysis.
extractOperands :: (Typeable p, Data p) => Expr p -> [Expr p]
extractOperands (Bin _ _ _ expr1 expr2) = extractOperands expr1 ++ extractOperands expr2
extractOperands expr 					= [expr]

--	Used to extract the name of a Var in a particular expression
extractVarNames :: (Typeable p, Data p) => Expr p -> [VarName p]
extractVarNames (Var _ _ lst) = map (\(x, _) -> x) lst
extractVarNames _ = []

--	Used to extract array index expressions and function call arguments.
extractContainedVars :: (Typeable p, Data p) => Expr p -> [Expr p]
extractContainedVars (Var _ _ lst) = foldl (\accumExprs (itemVar, itemExprs) -> accumExprs ++ itemExprs) [] lst
extractContainedVars _ = []

--	Generates a SrcSpan that is attached to nodes that have been generated by this program
nullSrcSpan :: SrcSpan
nullSrcSpan = (SrcLoc {srcFilename = "Generated", srcLine = -1, srcColumn = -1}, SrcLoc {srcFilename = "Generated", srcLine = -1, srcColumn = -1})

generateSrcSpan :: SrcSpan -> SrcSpan
generateSrcSpan ((SrcLoc sFile sLine sCol), (SrcLoc eFile eLine eCol)) = (SrcLoc {srcFilename = "Generated", srcLine = sLine, srcColumn = sCol}, SrcLoc {srcFilename = "Generated", srcLine = eLine, srcColumn = eCol})

--	Used to standardise SrcSpans so that nodes of an AST may be matched up even if they appear in completely different
--	parts of a program
--standardiseSrcSpan_trans ::(Data a, Typeable a) =>  Expr a -> Expr a
standardiseSrcSpan_trans :: Expr [String] -> Expr [String]
standardiseSrcSpan_trans = everywhere (mkT (standardiseSrcSpan))

standardiseSrcSpan :: SrcSpan -> SrcSpan
standardiseSrcSpan src = nullSrcSpan

hasOperand :: Expr [String] -> Expr [String] -> Bool
hasOperand container contains = all (== True) $ map (\x -> elem x (extractOperands $ standardiseSrcSpan_trans container)) (extractOperands $ standardiseSrcSpan_trans contains)

--	Appends a new item to the list of annotations already associated to a particular node
appendAnnotation :: Fortran [String] -> String -> Fortran [String]
appendAnnotation original appendage = case original of
		For anno f2 f3 f4 f5 f6 f7 -> For (anno ++ [appendage]) f2 f3 f4 f5 f6 f7
		OpenCLMap anno f2 f3 f4 f5 f6 -> OpenCLMap (anno ++ [appendage]) f2 f3 f4 f5 f6
		OpenCLReduce anno f2 f3 f4 f5 f6 f7 -> OpenCLReduce (anno ++ [appendage]) f2 f3 f4 f5 f6 f7
		_ -> original

--	Prepends a new item to the list of annotations already associated to a particular node
prependAnnotation :: Fortran [String] -> String -> Fortran [String]
prependAnnotation original appendage = case original of
		For anno f2 f3 f4 f5 f6 f7 -> For ([appendage] ++ anno) f2 f3 f4 f5 f6 f7
		OpenCLMap anno f2 f3 f4 f5 f6 -> OpenCLMap ([appendage] ++ anno) f2 f3 f4 f5 f6
		OpenCLReduce anno f2 f3 f4 f5 f6 f7 -> OpenCLReduce ([appendage] ++ anno) f2 f3 f4 f5 f6 f7
		_ -> original

--removeAllAnnotations :: Fortran [String] -> Fortran [String]
removeAllAnnotations original = everywhere (mkT removeAnnotations) original

removeAnnotations :: Fortran [String] -> Fortran [String]
removeAnnotations original = case original of
		For anno f2 f3 f4 f5 f6 f7 -> For [] f2 f3 f4 f5 f6 f7
		OpenCLMap anno f2 f3 f4 f5 f6 -> OpenCLMap [] f2 f3 f4 f5 f6
		OpenCLReduce anno f2 f3 f4 f5 f6 f7 -> OpenCLReduce [] f2 f3 f4 f5 f6 f7
		_ -> original


hasVarName :: [VarName [String]] -> Expr [String] -> Bool
hasVarName loopWrites (Var _ _ list) = foldl (\accum item -> if item then item else accum) False $ map (\(varname, exprs) -> elem varname loopWrites) list
hasVarName loopWrites _ = False


--	Takes two ASTs and appends on onto the other so that the resulting AST is in the correct format
appendFortran_recursive :: Fortran [String] -> Fortran [String] -> Fortran [String]
appendFortran_recursive newFortran (FSeq _ _ _ (FSeq _ _ _ fortran1)) = appendFortran_recursive newFortran fortran1 
appendFortran_recursive newFortran (FSeq _ _ fortran1 (NullStmt _ _)) = FSeq [] nullSrcSpan fortran1 newFortran
appendFortran_recursive newFortran (FSeq _ _ fortran1 fortran2) = FSeq [] nullSrcSpan fortran1 (FSeq [] nullSrcSpan fortran2 newFortran)
appendFortran_recursive newFortran codeSeg = FSeq [] nullSrcSpan codeSeg newFortran

--	Takes an AST and removes the loop statements from the node and joins up the rest of the code so that is it represented in the
--	format that language-fortran uses.
removeLoopConstructs_recursive :: Fortran [String] -> Fortran [String]
removeLoopConstructs_recursive (FSeq anno _ (For _ _ _ _ _ _ fortran1) fortran2) = removeLoopConstructs_recursive $ appendFortran_recursive fortran2 fortran1
removeLoopConstructs_recursive (For _ _ _ _ _ _ fortran) = removeLoopConstructs_recursive fortran
removeLoopConstructs_recursive (OpenCLMap _ _ _ _ _ fortran1) = removeLoopConstructs_recursive fortran1
removeLoopConstructs_recursive codeSeg = codeSeg