module LanguageFortranTools where

import Data.Generics (Data, Typeable, mkQ, mkT, gmapQ, gmapT, everything, everywhere)
import Language.Fortran.Parser
import Language.Fortran
import Data.Char
import Data.List

extractExprs :: Expr [String] -> Expr [String] 
extractExprs expr = expr

extractOperands :: (Typeable p, Data p) => Expr p -> [Expr p]
extractOperands (Bin _ _ _ expr1 expr2) = extractOperands expr1 ++ extractOperands expr2
extractOperands expr 					= [expr]

extractVarNames :: (Typeable p, Data p) => Expr p -> [VarName p]
extractVarNames (Var _ _ lst) = map (\(x, _) -> x) lst
extractVarNames _ = []

extractContainedVars :: (Typeable p, Data p) => Expr p -> [Expr p]
extractContainedVars (Var _ _ lst) = foldl (\accumExprs (itemVar, itemExprs) -> accumExprs ++ itemExprs) [] lst
extractContainedVars _ = []

--	Used as part of a foldl to concatentate expressions taken from 
concatExprList_foldl :: (Typeable p, Data p) => [Expr p] -> (VarName p, [Expr p]) -> [Expr p]
concatExprList_foldl prev (var, exprs) = prev ++ exprs

--	Generates a SrcSpan that is attached to nodes that have been generated by this program
generatedSrcSpan :: SrcSpan
generatedSrcSpan = (SrcLoc {srcFilename = "Generated", srcLine = -1, srcColumn = -1}, SrcLoc {srcFilename = "Generated", srcLine = -1, srcColumn = -1})

standardiseSrcSpan_trans ::(Data a, Typeable a) =>  Expr a -> Expr a
standardiseSrcSpan_trans = everywhere (mkT (standardiseSrcSpan))

standardiseSrcSpan :: SrcSpan -> SrcSpan
standardiseSrcSpan src = generatedSrcSpan

--	Takes two ASTs and appends on onto the other so that the resulting AST is in the correct format
appendFortran_recursive :: Fortran [String] -> Fortran [String] -> Fortran [String]
appendFortran_recursive newFortran (FSeq _ _ _ (FSeq _ _ _ fortran1)) = appendFortran_recursive newFortran fortran1 
appendFortran_recursive newFortran (FSeq _ _ fortran1 fortran2) = FSeq [] generatedSrcSpan fortran1 (FSeq [] generatedSrcSpan fortran2 newFortran)
appendFortran_recursive newFortran codeSeg = FSeq [] generatedSrcSpan codeSeg newFortran

--	Takes an AST and removes the loop statements from the node and joins up the rest of the code so that is it represented in the
--	format that language-fortran uses.
--removeLoopConstructs_recursive :: Fortran [String] -> Fortran [String]
--removeLoopConstructs_recursive (FSeq _ _ (For _ _ _ _ _ _ (FSeq anno srcspan fortran11 fortran12)) fortran02) = FSeq anno srcspan fortran11 
--																															(appendFortran_recursive 	(removeLoopConstructs_recursive fortran02) 
--																																						(removeLoopConstructs_recursive fortran12))
--removeLoopConstructs_recursive (FSeq _ _ (OpenCLMap _ _ _ _ _ (FSeq anno srcspan fortran11 fortran12)) fortran02) = FSeq anno srcspan fortran11 
--																															(appendFortran_recursive 	(removeLoopConstructs_recursive fortran02) 
--																																						(removeLoopConstructs_recursive fortran12))
--removeLoopConstructs_recursive (For _ _ _ _ _ _ fortran1) = removeLoopConstructs_recursive fortran1
--
--removeLoopConstructs_recursive (NullStmt anno srcspan) = NullStmt anno srcspan
--removeLoopConstructs_recursive codeSeg = gmapT (mkT removeLoopConstructs_recursive) codeSeg

removeLoopConstructs_recursive :: Fortran [String] -> Fortran [String]
removeLoopConstructs_recursive (FSeq anno _ (For _ _ _ _ _ _ fortran1) fortran2) = removeLoopConstructs_recursive $ appendFortran_recursive fortran2 fortran1
removeLoopConstructs_recursive (For _ _ _ _ _ _ fortran) = removeLoopConstructs_recursive fortran
removeLoopConstructs_recursive (OpenCLMap _ _ _ _ _ fortran1) = removeLoopConstructs_recursive fortran1
removeLoopConstructs_recursive codeSeg = codeSeg